#summary One-sentence summary of this page.

= Introduction =

Infector is a Inversion of Control container for doing dependency injection: (see [http://en.wikipedia.org/wiki/Inversion_of_control Wikipedia])It take advantage of the new C++11 language to provide a reliable and easy to use IoC container. In addition to most common features provided by IoC Containers.

==Constructor Injection==

Infector++ does only Construtor Injection (no setter injection: [http://misko.hevery.com/2009/02/19/constructor-injection-vs-setter-injection/ see related problems])

==Exception safety & leak prevention==

Infector is also a nice solution for removing memory leaks:
 * Is not possible having circular references (typical problem caused by bad usage of [http://en.cppreference.com/w/cpp/memory/shared_ptr/reset shared_ptr])
 * All dependencies are "managed" thanks to smart pointers usage, you don't have to call "new" or "delete".
 * If any method of Infector::Container throws an exception the Container will be left unchanged (strong guarantee)
 * If any of your constructors throws an exception, Infector will not cause memory leaks.

(Memory allocated by you can still cause memory leaks, the point is that you will almost never have to manually allocated something).

*Future releases*

Some extra features will come with next releases

 * Nested containers (will be the only way to provide contextual binding, each container can provide a different implementation to a interface that was bound by its parent)
 * Custom allocation:
  # Infector knows how your objects are wired up, and can exploit that to reduce significatively the number of allocations and at same time can improve cache locality.(Infector++ was not originally thinked to improve performance, but after some tests, I found that the compiler greatly optimize all the templated stuff for execution speed)
  # Set custom allocator provided by user (since Infector already batch allocations where needed you can focus on other optimizations, if you build 50 different objects then there will be only 50 possible allocation sizes, not including batched dependencies and shared objects that will not be batched)
 * Report unused dependencies: if some class was not used you'll know that, and you will be able to remove dead code from your project, this will be partially provided by Nested Containers and by extra code in Containers' destructors.