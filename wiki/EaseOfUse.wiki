Infector manages 2 kind of objects:
 * Shared Objects (they will be injected using a *shared_ptr*, only 1 istance of each object is created)
 * Unique Objects (they will be injected using a *unique_ptr*, many istances of each object are created, but every istance is owned only by 1 other object)

Shared Pointers are nice, but if heavily used/misused can cause more troubles (each reference counter need to be allocated, it is easy to have circular references by accidentally pass around a shared_ptr and then this will cause a memory leak). Most of troubles are solved by simply using "unique_ptr", it can't be accidentally passed around (requires a explicit "std::move") it does not require to allocate a reference counter, and so is almost the best way to inject dependencies on something that is not shared.

||*Number of istances*||*Single Istance*||*Many Istances*||
||Smart pointer type||std::shared_ptr||std::unique_ptr||
||Concrete binding || bindSingleAsNothing|| bindAsNothing||
||Polymorphic binding|| bindSingleAs || bindAs||

==Polymorphic Binding==
Registering classes to be istantiated is done by calling "bind...", this is part of a 2-steps process necessary to do polymorphic binding.
How that works? That's simple don't warry.

If you have "CFoo" and you want to inject it using its interface "IFoo", you have just to Bind "CFoo" as "IFoo" (so later you can forgot about CFoo and request IFoo instead).

this is done by:
{{{
ioc.bindAs<CFoo, IFoo>(); //bind CFoo as IFoo
//later you can do
auto myFoo = ioc.build<IFoo>(); //you are no longer dependent on CFoo
}}}

You are not forced to do polymorphic binding, but since polymorphic binding is usually preferred, if you want to skip that, you have to type a bit more

this is done by:
{{{
ioc.bindAsNothing<CFoo>(); //bind CFoo as nothing
//later you can do
auto myFoo = ioc.build<CFoo>(); //you are still dependent on CFoo
}}}