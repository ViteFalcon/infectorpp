Infector manages 2 kind of objects:
 * Shared Objects (they will be injected using a *shared_ptr*, only 1 istance of each object is created)
 * Unique Objects (they will be injected using a *unique_ptr*, many istances of each object are created, but every istance is owned only by 1 other object)

Shared Pointers are nice, but if heavily used/misused can cause more troubles (each reference counter need to be allocated, it is easy to have circular references by accidentally pass around a shared_ptr and then this will cause a memory leak). Most of troubles are solved by simply using "unique_ptr", it can't be accidentally passed around (requires a explicit "std::move") it does not require to allocate a reference counter, and so is almost the best way to inject dependencies on something that is not shared.

|| *Number of istances* || *Single Istance* || *Many Istances* ||
|| Smart pointer type || std::shared_ptr || std::unique_ptr ||
|| Concrete binding || bindSingleAsNothing || bindAsNothing ||
|| Interface binding || bindSingleAs || bindAs ||

==Interface Binding==
Registering classes to be istantiated is done by calling "bind...", this is part of a 2-steps process necessary to do interface binding.
How that works? That's simple don't warry.

If you have "CFoo" and you want to inject it using its interface "IFoo", you have just to Bind "CFoo" as "IFoo" (so later you can forgot about CFoo and request for IFoo only instead).

this is done by:
{{{
ioc.bindAs<CFoo, IFoo>(); //bind CFoo as IFoo
//later you can do
auto myFoo = ioc.build<IFoo>(); //you are no longer dependent on CFoo
}}}

You are not forced to do interface binding, but since interface binding is usually preferred, if you want to skip that, you have to type a bit more.

this is done by:
{{{
ioc.bindAsNothing<CFoo>(); //bind CFoo as nothing
//later you can do
auto myFoo = ioc.build<CFoo>(); //you are still dependent on CFoo
}}}

IMPORTANT!
 * "bindAs" allows to bind only 1 interface
 * Each interface can only have 1 implementation

==Single Istances==
You can also create Objects that have to be shared, (by the way, Infector++ is not a service locator). In that case only 1 istance will be created for each object.

Since shared objects are.. shared.. it is allowed to bind them to multiple interfaces (Note: each interface is still limited to *1 implementation*). This helps a bit more to specialize shared objects. If you have "!FoodFactory" that implements multiple interfaces "ITunaFactory" and "IBeansFactory", you can do:
{{{
ioc.bindSingleAs<FoodFactory, ITunaFactory, IBeansFactory>(); //bind FoodFactory as ITunaFactory and as IBeansFactory
//later you can do
auto myTunaFactory = ioc.buildSingle<ITunaFactory>(); //if you need only ITunaFactory
auto myBeansFactory = ioc.buildSingle<IBeansFactory>(); //if you need only IBeansFactory
}}}


Even if more discouraged you can still bind shared objects to no interfaces:
{{{
ioc.bindSingleAsNothing<FoodFactory>(); //bind singleIstance of FoodFactory as Nothing
//later you can do
auto myTunaFactory = ioc.buildSingle<FoodFactory>(); //you are still dependent on FoodFactory
auto myBeansFactory = ioc.buildSingle<FoodFactory>();//you are still dependent on FoodFactory
}}}

==Wiring==
Wiring is the 2nd step necessary to inject dependencies. 
by Binding CFoo as IFoo, what I'm really telling to computer is 
"When I ask for IFoo, you must create CFoo by calling its constructor, then return me CFoo by casting it to IFoo"
This is a bit of work.. but you still need the constructor, so you have to "wire" it.

Wiring is very simple, basically you have to list all the dependencies, everything else is done by Infector++:
{{{
//your class
class JustAClass:public virtual IInterfaceOfClass{
public:
    JustAClass(std::unique_ptr<dependency1> p1,
               std::shared_ptr<dependency2> p2,
               std::uinque_ptr<dependency3> p3);
};

//...

// the wiring
ioc.wire<JustAClass, dependency1, dependency2, dependency3>();
}}}
As you see there's no limit to number of constructor arguments.. As long as they are passed as "unique_ptr" or "shared_ptr".
Of course everything must be bound first. In case you miss something you will get an exception. If you want to call Default Constructor this is the way:
{{{
class AnotherClass{
public:
    AnotherClass(); //default ctor
};
}}}

== Proper way to do things ==
 
Keep "Binding" "Wiring" and "Building" separed (you cannot wire something that is not bound, and you cannot build something that is not wired)

{{{

void compositionRoot(Infector::Container & ioc){
    //BINDINGS
    ioc.bindSingleAs<FoodFactory, ITunaFactory, IBeansFactory>();
    ioc.bindSingleAs<MainLoop, IApplication>(); 
    //...

    //WIRING
    ioc.wire<FoodFactory>(); //default ctor for FoodFactory
    ioc.wire<MainLoop, ITunaFactory, IBeansFactory>(); // assume main loop takes some factories as parameter.
    //... 
}

int main(){
    Infector::Container ioc;
    compositionRoot(ioc);
    //BUILDING
    auto app=ioc.build<IApplication>(); //creates MainLoop, it has some factories
    app->run(); //run the application (can creates objects thanks to factories).

    return 0;
}
}}}